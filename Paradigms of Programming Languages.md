# Programming Language Paradigms

![Struccture](https://github.com/ALTONIBOT/Embargo-Breaker/blob/main/UI-UX/hint-img/Pa.png)

> پارادایم های برنامه نویسی راهی برای طبقه بندی زبان های برنامه نویسی بر اساس ویژگی های آنهاست. زبان ها را می توان به چند پارادایم طبقه بندی کرد.
برخی از پارادایم ها عمدتاً به مفاهیمی برای مدل اجرای زبان مربوط می شوند، مانند اجازه دادن به عوارض جانبی، یا اینکه آیا توالی عملیات توسط مدل اجرا تعریف می شود. پارادایم های دیگر عمدتاً به نحوه سازماندهی کد مربوط می شوند، مانند گروه بندی یک کد به واحدها همراه با حالتی که توسط کد اصلاح می شود. با این حال، دیگران عمدتاً به سبک نحو و دستور زبان توجه دارند.

برخی از پارادایم های رایج برنامه نویسی عبارتند از...

## Imperative

+ امری که در آن برنامه نویس به ماشین دستور می دهد که چگونه حالت خود را تغییر دهد

### procedural

> رویه ای که دستورالعمل ها را به رویه ها گروه بندی می کند

* Basic | C | FORTRAN | JAVA | Pascal | Ada | Algol | Assembly | bash | COBOL | Lisp | Lua | MATLAB | Perl | R | Visual Basic

### object-oriented

> شی گرا که دستورالعمل ها را با بخشی از حالتی که روی آن عمل می کنند گروه بندی می کند

* Python | JAVA | C++ | C# | Ruby | Swift | Kotlin | PHP | TypeScript | Objective-C | Scala

### Parallel processing

> پردازش موازی پارادایم است که به یک برنامه اجازه می دهد تا چندین کار را به طور همزمان با استفاده از بیش از یک پردازنده یا کامپیوتر انجام دهد. پردازش موازی می تواند عملکرد، کارایی و مقیاس پذیری یک برنامه را بهبود بخشد، به ویژه برای مشکلات محاسباتی فشرده. همچنین می توان از پردازش موازی برای دستیابی به تحمل خطا، متعادل سازی بار و محاسبات توزیع شده استفاده کرد.

* 

## Declarative

+ اعلامی که در آن برنامه نویس صرفاً ویژگی های نتیجه مورد نظر را اعلام می کند، اما نحوه محاسبه آن را نه

### functional

> تابعی که در آن نتیجه مورد نظر به عنوان مقدار یک سری از برنامه های کاربردی اعلام می شود

* Clojure | Elixir | Haskell | Scala | Pyrhon | Elm | F# | Erlang | PHP | JavaScript | Java | C++ | Idris | Scheme | GO | Rust | Kotlin | C# | TypeScript | ReasonML | PureScript | Swift

### logic

> منطقی که در آن نتیجه مطلوب به عنوان پاسخ به سؤالی در مورد سیستمی از حقایق و قوانین اعلام می شود

* Prolog | Datalog | ASP | Absys | Alma-0 | CycL | Epilog

### reactive

> واکنشی که در آن نتیجه مورد نظر با جریان های داده و انتشار تغییرات اعلام می شود

* Elixir | Haskell | Swift

---

تکنیک‌های نمادین مانند بازتاب، که به برنامه اجازه می‌دهد به خود ارجاع دهد، ممکن است به عنوان یک الگوی برنامه‌نویسی در نظر گرفته شود. با این حال، این با پارادایم های اصلی سازگار است و بنابراین به خودی خود یک پارادایم واقعی نیست.
برای مثال، زبان‌هایی که در پارادایم امری قرار می‌گیرند، دو ویژگی اصلی دارند: ترتیب انجام عملیات را بیان می‌کنند، با ساختارهایی که به صراحت آن ترتیب را کنترل می‌کنند، و اجازه عوارض جانبی را می‌دهند که در آن حالت می‌توان در یک نقطه از زمان تغییر داد. در یک واحد کد، و سپس در یک نقطه زمانی متفاوت در یک واحد کد متفاوت خوانده شود. ارتباط بین واحدهای کد صریح نیست. در همین حال، در برنامه نویسی شی گرا، کد به اشیایی سازماندهی می شود که دارای حالتی است که فقط توسط کدی که بخشی از شی است، تغییر می یابد. بیشتر زبان های شی گرا نیز زبان های امری هستند. در مقابل، زبان‌هایی که با پارادایم اعلامی تناسب دارند، ترتیب اجرای عملیات را بیان نمی‌کنند. در عوض، آنها تعدادی عملیات موجود در سیستم را همراه با شرایطی که تحت آن هر کدام مجاز به اجرا هستند، ارائه می کنند. پیاده‌سازی مدل اجرای زبان، اجرای آزادانه عملیات را دنبال می‌کند و ترتیب را به‌طور مستقل انتخاب می‌کند. بیشتر در مقایسه زبان های برنامه نویسی چند پارادایم.

همانطور که مهندسی نرم افزار (به عنوان یک فرآیند) با روش های مختلف تعریف می شود، زبان های برنامه نویسی (به عنوان مدل های محاسبات) نیز با پارادایم های متفاوت تعریف می شوند. برخی از زبان ها برای پشتیبانی از یک پارادایم طراحی شده اند (Smalltalk از برنامه نویسی شی گرا پشتیبانی می کند، Haskell از برنامه نویسی تابعی پشتیبانی می کند)، در حالی که سایر زبان های برنامه نویسی از چندین پارادایم پشتیبانی می کنند (مانند Object Pascal، C++، Java، JavaScript، C#، Scala، Visual Basic، Common Lisp. ، Scheme، Perl، PHP، Python، Ruby، Oz و F#). به عنوان مثال، برنامه های نوشته شده در C++، Object Pascal یا PHP می توانند صرفاً رویه ای، صرفاً شی گرا باشند یا می توانند حاوی عناصر هر دو یا سایر پارادایم ها باشند. طراحان و برنامه نویسان نرم افزار تصمیم می گیرند که چگونه از آن عناصر پارادایم استفاده کنند.

در برنامه نویسی شی گرا، برنامه ها به عنوان مجموعه ای از اشیاء متقابل در نظر گرفته می شوند. در برنامه نویسی تابعی، برنامه ها به عنوان دنباله ای از ارزیابی عملکرد بدون حالت در نظر گرفته می شوند. هنگام برنامه نویسی کامپیوترها یا سیستم هایی با تعداد زیادی پردازنده، در برنامه نویسی فرآیند گرا، برنامه ها به عنوان مجموعه ای از فرآیندهای همزمان در نظر گرفته می شوند که بر روی یک ساختار داده مشترک منطقی عمل می کنند.

بسیاری از پارادایم های برنامه نویسی به دلیل تکنیک هایی که آنها را ممنوع کرده اند، شناخته شده اند. به عنوان مثال، برنامه نویسی کاربردی خالص استفاده از عوارض جانبی را ممنوع می کند، در حالی که برنامه نویسی ساخت یافته استفاده از دستور goto را ممنوع می کند. تا حدی به همین دلیل، پارادایم های جدید اغلب به عنوان دکترینی یا بیش از حد سخت توسط کسانی که به سبک های قبلی عادت کرده اند در نظر گرفته می شوند. با این حال، اجتناب از تکنیک‌های خاص می‌تواند درک رفتار برنامه و اثبات قضایای درستی برنامه را آسان‌تر کند.

پارادایم های برنامه نویسی را می توان با مدل های برنامه نویسی نیز مقایسه کرد که تنها با استفاده از یک API امکان فراخوانی یک مدل اجرا را فراهم می کند. مدل های برنامه نویسی را نیز می توان بر اساس ویژگی های مدل اجرا به پارادایم ها طبقه بندی کرد.

برای محاسبات موازی، استفاده از مدل برنامه نویسی به جای زبان رایج است. دلیل آن این است که جزئیات سخت افزار موازی به انتزاعات مورد استفاده برای برنامه ریزی سخت افزار نشت می کند. این امر باعث می شود برنامه نویس مجبور شود الگوهای الگوریتم را روی الگوهای موجود در مدل اجرا (که به دلیل نشت سخت افزار در انتزاع درج شده اند) نگاشت کند. در نتیجه، هیچ یک از زبان های برنامه نویسی موازی به خوبی برای همه مسائل محاسباتی نگاشت نمی شوند. بنابراین، استفاده از یک زبان متوالی پایه و درج فراخوانی های API به مدل های اجرای موازی از طریق یک مدل برنامه نویسی راحت تر است. چنین مدل‌های برنامه‌نویسی موازی را می‌توان بر اساس انتزاعی‌هایی که سخت‌افزار را منعکس می‌کنند، مانند حافظه مشترک، حافظه توزیع شده با ارسال پیام، مفاهیم مکان قابل مشاهده در کد و غیره طبقه‌بندی کرد. این‌ها را می‌توان نمونه‌هایی از الگوی برنامه‌نویسی در نظر گرفت که فقط برای زبان‌های موازی و مدل‌های برنامه‌نویسی کاربرد دارند.


رویکردهای متفاوتی برای برنامه نویسی در طول زمان توسعه یافته است که در آن زمان یا به صورت گذشته نگر به این صورت شناسایی شده است. یک رویکرد اولیه که آگاهانه به عنوان چنین شناخته شده است، برنامه نویسی ساختاریافته است که از اواسط دهه 1960 مورد حمایت قرار گرفت. مفهوم «پارادایم برنامه‌نویسی» حداقل به سال 1978 در سخنرانی جایزه تورینگ رابرت دبلیو فلوید با عنوان پارادایم‌های برنامه‌نویسی برمی‌گردد که به مفهوم پارادایم همانطور که توماس کوهن در ساختار علمی خود استفاده کرده است، اشاره می‌کند. انقلاب ها (1962). زبان‌های برنامه‌نویسی اولیه پارادایم‌های برنامه‌نویسی مشخصی نداشتند و گاهی برنامه‌ها به طور گسترده از دستورات goto استفاده می‌کردند، استفاده آزادانه از این عبارات منجر به "کد اسپاگتی" می‌شد که کار با آن دشوار است. این منجر به توسعه پارادایم‌های برنامه‌نویسی ساخت‌یافته شد که استفاده از دستورات goto را مجاز نمی‌دانستند و فقط استفاده از ساختارهای برنامه‌نویسی به وضوح تعریف شده را مجاز می‌دانستند.

کد ماشین
پارادایم های برنامه نویسی پایین ترین سطح، کد ماشین هستند که مستقیماً دستورالعمل ها (محتوای حافظه برنامه) را به عنوان دنباله ای از اعداد نشان می دهد، و زبان اسمبلی که در آن دستورالعمل های ماشین با یادگاری نمایش داده می شود و آدرس های حافظه را می توان برچسب های نمادین داد. گاهی اوقات به این زبان ها زبان های نسل اول و دوم می گویند.

در دهه 1960، زبان‌های اسمبلی برای پشتیبانی از COPY کتابخانه‌ای و توانایی‌های پیش‌پردازش و تولید ماکرو شرطی کاملاً پیچیده، CALL to (زیر روال‌ها)، متغیرهای خارجی و بخش‌های مشترک (جهانی)، توسعه یافتند که امکان استفاده مجدد قابل توجه از کد و جداسازی از ویژگی‌های سخت‌افزاری را از طریق استفاده از عملگرهای منطقی مانند READ/WRITE/GET/PUT. اسمبلی برای سیستم‌های حساس زمان و اغلب در سیستم‌های تعبیه‌شده استفاده می‌شود، و هنوز هم استفاده می‌شود، زیرا مستقیم‌ترین کنترل را بر آنچه ماشین انجام می‌دهد، می‌دهد.

زبانهای رویه ای
پیشرفت بعدی توسعه زبان های رویه ای بود. این زبان‌های نسل سوم (اولین زبان‌هایی که به عنوان زبان‌های سطح بالا توصیف می‌شوند) از واژگان مرتبط با مشکل در حال حل استفاده می‌کنند. مثلا،

زبان تجاری متداول (COBOL) - از عباراتی مانند فایل، انتقال و کپی استفاده می کند.
ترجمه فرمول (FORTRAN) - با استفاده از اصطلاحات زبان ریاضی، عمدتاً برای مسائل علمی و مهندسی توسعه یافته است.
زبان الگوریتمی (ALGOL) – تمرکز بر زبانی مناسب برای تعریف الگوریتم‌ها، در حالی که از اصطلاحات زبان ریاضی استفاده می‌کند و مشکلات علمی و مهندسی را هدف قرار می‌دهد، درست مانند FORTRAN.
زبان برنامه نویسی یک (PL/I) - یک زبان ترکیبی تجاری-علمی با هدف عمومی پشتیبانی از اشاره گرها.
کد دستور العمل نمادین همه منظوره مبتدیان (BASIC) – این کد برای قادر ساختن افراد بیشتری به نوشتن برنامه ها ایجاد شده است.
C – یک زبان برنامه نویسی همه منظوره است که در ابتدا توسط دنیس ریچی بین سال های 1969 تا 1973 در آزمایشگاه AT&T Bell توسعه یافت.
همه این زبان ها از پارادایم رویه ای پیروی می کنند. یعنی گام به گام دقیقاً رویه ای را توصیف می کنند که حداقل طبق نظر برنامه نویس خاص باید برای حل یک مشکل خاص دنبال شود. بنابراین، کارایی و کارایی هر راه حلی کاملاً ذهنی است و به شدت به تجربه، خلاقیت و توانایی برنامه نویس بستگی دارد.

برنامه نویسی شی گرا
مقاله اصلی: برنامه نویسی شی گرا
به دنبال استفاده گسترده از زبان های رویه ای، زبان های برنامه نویسی شی گرا (OOP) مانند Simula، Smalltalk، C++، Eiffel، Python، PHP، Java و C# ایجاد شدند. در این زبان ها، داده ها و روش های دستکاری آن به عنوان یک واحد به نام یک شی نگهداری می شوند. با کپسوله‌سازی کامل، یکی از ویژگی‌های متمایز OOP، تنها راهی که شی یا کاربر دیگری می‌تواند به داده‌ها دسترسی پیدا کند، روش‌های شی است. بنابراین، عملکرد درونی یک شی ممکن است بدون تأثیر روی کدی که از شی استفاده می کند، تغییر کند. هنوز هم بحث‌هایی وجود دارد که توسط الکساندر استپانوف، ریچارد استالمن و برنامه‌نویسان دیگر در مورد کارایی پارادایم OOP در مقابل پارادایم رویه‌ای مطرح شده است. نیاز به هر شی به روش های انجمنی باعث می شود که برخی از شکاکان OOP را با نرم افزار bloat مرتبط کنند. تلاش برای حل این معضل از طریق چندشکلی انجام شد.

از آنجایی که برنامه نویسی شی گرا یک پارادایم در نظر گرفته می شود، نه یک زبان، می توان حتی یک زبان اسمبلر شی گرا ایجاد کرد. اسمبلی سطح بالا (HLA) نمونه ای از این است که به طور کامل از انواع داده های پیشرفته و برنامه نویسی زبان اسمبلی شی گرا - علی رغم منشأ اولیه آن - پشتیبانی می کند. بنابراین، پارادایم‌های برنامه‌نویسی متفاوت را می‌توان به‌جای نمایش‌دهنده پیشرفت از یک سطح به سطح بعدی، بیشتر شبیه الگوهای انگیزشی طرفدارانشان دید. مقایسه دقیق کارآیی پارادایم‌های رقیب اغلب به دلیل اصطلاحات جدید و متفاوتی که برای موجودیت‌ها و فرآیندهای مشابه به کار می‌رود، همراه با تمایزات پیاده‌سازی متعدد در زبان‌ها، دشوارتر می‌شود.

پارادایم های بیشتر
برنامه‌نویسی باسواد، به‌عنوان شکلی از برنامه‌نویسی ضروری، برنامه‌ها را به‌عنوان یک وب انسان‌محور ساختار می‌دهد، مانند یک مقاله فرامتن: مستندات جزء لاینفک برنامه هستند، و برنامه به‌جای راحتی کامپایلر، بر اساس منطق بیان نثر ساختار یافته است.

مستقل از شاخه امری، پارادایم های برنامه نویسی اعلانی توسعه یافتند. در این زبان‌ها، به رایانه گفته می‌شود که مشکل چیست، نه اینکه چگونه مشکل را حل کند - برنامه به‌عنوان مجموعه‌ای از ویژگی‌ها برای یافتن در نتیجه مورد انتظار ساخته شده است، نه به‌عنوان روشی که باید دنبال شود. با توجه به یک پایگاه داده یا مجموعه ای از قوانین، کامپیوتر سعی می کند راه حلی را پیدا کند که با تمام ویژگی های مورد نظر مطابقت داشته باشد. کهن الگوی یک زبان اعلامی، زبان نسل چهارم SQL و خانواده زبان های تابعی و برنامه نویسی منطقی است.

برنامه نویسی تابعی زیر مجموعه ای از برنامه نویسی اعلانی است. برنامه‌هایی که با استفاده از این پارادایم نوشته می‌شوند، از توابع استفاده می‌کنند، بلوک‌هایی از کد که مانند توابع ریاضی عمل می‌کنند. زبان‌های تابعی از تغییر در مقدار متغیرها از طریق انتساب جلوگیری می‌کنند و به جای آن از بازگشت استفاده زیادی می‌کنند.

پارادایم برنامه نویسی منطقی، محاسبات را به عنوان استدلال خودکار بر روی مجموعه ای از دانش می بیند. حقایق مربوط به حوزه مسئله به صورت فرمول های منطقی بیان می شوند و برنامه ها با اعمال قوانین استنتاج بر روی آنها اجرا می شوند تا زمانی که پاسخی برای مسئله پیدا شود یا مجموعه فرمول ها ناسازگار باشند.

برنامه نویسی نمادین الگویی است که برنامه هایی را توصیف می کند که قادر به دستکاری فرمول ها و اجزای برنامه به عنوان داده هستند. بنابراین برنامه‌ها می‌توانند به‌طور مؤثر خود را اصلاح کنند، و به نظر می‌رسند که «یاد می‌گیرند»، و آن‌ها را برای کاربردهایی مانند هوش مصنوعی، سیستم‌های خبره، پردازش زبان طبیعی و بازی‌های رایانه‌ای مناسب می‌سازند. زبان هایی که از این پارادایم پشتیبانی می کنند عبارتند از Lisp و Prolog.

برنامه نویسی متمایز، برنامه ها را طوری ساختار می دهد که بتوان آنها را در سرتاسر، معمولاً از طریق تمایز خودکار، متمایز کرد.


# [منبع](https://en.m.wikipedia.org/wiki/Programming_paradigm)